//  â•”â—Žâ˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±[ OpenBot by magneum ]â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â—Ž"
//  â•‘â§‰à¼» ðŸ¤–ðŽð©ðžð§ðð¨ð­ðŸ˜ºðŒð®ð¥ð­ð¢-ðƒðžð¯ð¢ðœðžðŸ¤–
//  â•‘  ð¢ð¬ ðš ð–ð¡ðšð­ð¬ðšð©ð© ðŒð®ð¥ð­ð¢ðð®ð«ð©ð¨ð¬ðž - ð”ð¬ðžð«ð›ð¨ð­ ð°ð¢ð­ð¡ ðŒð¨ððžð«ðšð­ð¢ð¨ð§, ð€ð®ð­ð¨ð¦ðšð­ð¢ð¨ð§ ðšð§ð ðŸðŸŽðŸŽ++ ð¦ð¨ð«ðž ðœð¨ð¦ð¦ðšð§ðð¬!
//  â•‘
//  â•‘ðŸŒŸ A versatile whatsApp multi-purpose bot designed for group management and user convenience.
//  â•‘ðŸš€ Simplifies group management tasks and enhances the overall user experience.
//  â•‘âš ï¸ Please note: Engaging in spamming activities may lead to account suspension. Use responsibly!
//  â•‘ðŸŽ‰ OpenBot is intended for fun and convenience, but we're not responsible for account bans.
//  â•‘ðŸ”€ forking the repository is allowed, but customized versions or modified plugins are unsupported.
//  â•‘âš ï¸ Exercise caution and take responsibility for any modifications made to the bot.
//  â•‘ðŸ“ž Need assistance or have issues? Contact our developers at +918436686758 and +918250889325.
//  â•‘ðŸ”„ We'll continue providing updates and support for the original version of the bot.
//  â•‘ðŸ‘‰ Enjoy the features and functionality of OpenBot responsibly! Make the most out of your
//  â•‘   whatsApp group management experience! ðŸŽ‰
//  â•‘
//  â•‘ðŸž Developers: +918436686758, +918250889325
//  â•šâ—Žâ˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±[ OpenBot by magneum ]â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â˜±â—Ž"
var fs = require("fs");
var { tmpdir } = require("os");
var Crypto = require("crypto");
var ff = require("fluent-ffmpeg");
var webp = require("node-webpmux");
var path = require("path");

async function imageToWebp(media) {
  var tmpFileOut = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  var tmpFileIn = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.png`
  );

  fs.writeFileSync(tmpFileIn, media);

  await new Promise((resolve, reject) => {
    ff(tmpFileIn)
      .on("error", reject)
      .on("end", () => resolve(true))
      .addOutputOptions([
        "-vcodec",
        "libwebp",
        "-vf",
        "scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] pavartegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] pavarteuse",
      ])
      .toformat("webp")
      .save(tmpFileOut);
  });

  var buff = fs.readFileSync(tmpFileOut);
  fs.unlinkSync(tmpFileOut);
  fs.unlinkSync(tmpFileIn);
  return buff;
}

async function videoToWebp(media) {
  var tmpFileOut = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  var tmpFileIn = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.mp4`
  );

  fs.writeFileSync(tmpFileIn, media);

  await new Promise((resolve, reject) => {
    ff(tmpFileIn)
      .on("error", reject)
      .on("end", () => resolve(true))
      .addOutputOptions([
        "-vcodec",
        "libwebp",
        "-vf",
        "scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] pavartegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] pavarteuse",
        "-loop",
        "0",
        "-ss",
        "00:00:00",
        "-t",
        "00:00:05",
        "-preset",
        "default",
        "-an",
        "-vsync",
        "0",
      ])
      .toformat("webp")
      .save(tmpFileOut);
  });

  var buff = fs.readFileSync(tmpFileOut);
  fs.unlinkSync(tmpFileOut);
  fs.unlinkSync(tmpFileIn);
  return buff;
}

async function writeExifImg(media, metadata) {
  var wMedia = await imageToWebp(media);
  var tmpFileIn = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  var tmpFileOut = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  fs.writeFileSync(tmpFileIn, wMedia);

  if (metadata.packname || metadata.author) {
    var img = new webp.Image();
    var json = {
      "sticker-pack-id": `https://github.com/pratyush4932`,
      "sticker-pack-name": metadata.packname,
      "sticker-pack-publisher": metadata.author,
      emojis: metadata.categories ? metadata.categories : [""],
    };
    var exifAttr = Buffer.from([
      0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
    ]);
    var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8");
    var exif = Buffer.concat([exifAttr, jsonBuff]);
    exif.writeUIntLE(jsonBuff.length, 14, 4);
    await img.load(tmpFileIn);
    fs.unlinkSync(tmpFileIn);
    img.exif = exif;
    await img.save(tmpFileOut);
    return tmpFileOut;
  }
}

async function writeExifVid(media, metadata) {
  var wMedia = await videoToWebp(media);
  var tmpFileIn = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  var tmpFileOut = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  fs.writeFileSync(tmpFileIn, wMedia);

  if (metadata.packname || metadata.author) {
    var img = new webp.Image();
    var json = {
      "sticker-pack-id": `https://github.com/DikaArdnt/Hisoka-Morou`,
      "sticker-pack-name": metadata.packname,
      "sticker-pack-publisher": metadata.author,
      emojis: metadata.categories ? metadata.categories : [""],
    };
    var exifAttr = Buffer.from([
      0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
    ]);
    var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8");
    var exif = Buffer.concat([exifAttr, jsonBuff]);
    exif.writeUIntLE(jsonBuff.length, 14, 4);
    await img.load(tmpFileIn);
    fs.unlinkSync(tmpFileIn);
    img.exif = exif;
    await img.save(tmpFileOut);
    return tmpFileOut;
  }
}

async function writeExif(media, metadata) {
  var wMedia = /webp/.test(media.mimetype)
    ? media.data
    : /image/.test(media.mimetype)
    ? await imageToWebp(media.data)
    : /video/.test(media.mimetype)
    ? await videoToWebp(media.data)
    : "";
  var tmpFileIn = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  var tmpFileOut = path.join(
    tmpdir(),
    `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`
  );
  fs.writeFileSync(tmpFileIn, wMedia);

  if (metadata.packname || metadata.author) {
    var img = new webp.Image();
    var json = {
      "sticker-pack-id": `https://github.com/DikaArdnt/Hisoka-Morou`,
      "sticker-pack-name": metadata.packname,
      "sticker-pack-publisher": metadata.author,
      emojis: metadata.categories ? metadata.categories : [""],
    };
    var exifAttr = Buffer.from([
      0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57,
      0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
    ]);
    var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8");
    var exif = Buffer.concat([exifAttr, jsonBuff]);
    exif.writeUIntLE(jsonBuff.length, 14, 4);
    await img.load(tmpFileIn);
    fs.unlinkSync(tmpFileIn);
    img.exif = exif;
    await img.save(tmpFileOut);
    return tmpFileOut;
  }
}

module.exports = {
  imageToWebp,
  videoToWebp,
  writeExifImg,
  writeExifVid,
  writeExif,
};
